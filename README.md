# <center>Informe del Trabajo Final</center>

<p align="center">
    <strong>Universidad Peruana de Ciencias Aplicadas</strong><br>
    <img src="https://upload.wikimedia.org/wikipedia/commons/f/fc/UPC_logo_transparente.png"></img><br>
    <strong>Ingeniería de Software</strong><br>
    <strong>[Nombre del Curso]</strong><br>
    <strong>Profesor: [Nombre del Profesor]</strong><br>
    <br>INFORME
</p>

<center>

#### Startup: **AlquildoreEz**

#### Product: **Alquila Facil**

</center>

## Team Members:

<div align="center">

|               Member                |    Code    |
| :---------------------------------: | :--------: |
|                                     |            |
|                                     |            |
|                                     |            |
|                                     |            |
|                                     |            |
|                                     |            |

</div>

# Registro de Versiones del Informe

<table>
    <thead>
    <tr>
        <th>Version</th>
        <th>Fecha</th>
        <th>Autor</th>
        <th>Descripción de modificación</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td> </td>
        <td> </td>
        <td> </td>
        <td>
        <ul>
        <li>  </li>
        <li> </li>
        <li> </li>
        </ul>
        </td>
    </tr>
    <tr>
        <td> </td>
        <td> </td>
        <td> </td>
        <td>
        <ul>
        <li>  </li>
        <li>  </li>
        <li>  </li>
        </ul>
        </td>
    </tr>
    <tr>  
    </tr>
    <tr>
        <td> </td>
        <td> </td>
        <td> </td>
        <td>
        <ul>
        <li>   </li>
        <li>   </li>
        <li>   </li>
        </ul>
        </td>
    </tr>
    <tr>
        <td> </td>
        <td> </td>
        <td>  </td>
        <td>
        <ul>
        <li>   </li>
        <li>   </li>
        <li>   </li>
        </ul>
        </td>
    </tr>
    <tr>
        <td> </td>
        <td> </td>
        <td>   </td>
        <td>
        <ul>
        <li>   </li>
        <li>   </li>
        <li>   </li>
        </ul>
        </td>
    </tr>
    <tr>
        <td> </td>
        <td> </td>
        <td>   </td>
        <td>
        <ul>
        <li>   </li>
        <li>   </li>
        <li>   </li>
        <li>   </li>
        </ul>
        </td>
    </tr>
    </tbody>
</table>

---

# Project Report Collaboration Insights

---

# Student Outcome

---

# Contenido

- [Capítulo I: Introducción](#capítulo-i-introducción)
  - [1.1. Startup Profile](#11-startup-profile)
    - [1.1.1. Descripción de la Startup](#111-descripción-de-la-startup)
    - [1.1.2. Perfiles de integrantes del equipo](#112-perfiles-de-integrantes-del-equipo)
  - [1.2. Solution Profile](#12-solution-profile)
    - [1.2.1. Antecedentes y problemática](#121-antecedentes-y-problemática)
    - [1.2.2. Lean UX Process](#122-lean-ux-process)
      - [1.2.2.1. Lean UX Problem Statements](#1221-lean-ux-problem-statements)
      - [1.2.2.2. Lean UX Assumptions](#1222-lean-ux-assumptions)
      - [1.2.2.3. Lean UX Hypothesis Statements](#1223-lean-ux-hypothesis-statements)
      - [1.2.2.4. Lean UX Canvas](#1224-lean-ux-canvas)
  - [1.3. Segmentos objetivo](#13-segmentos-objetivo)

- [Capítulo II: Requirements Elicitation & Analysis](#capítulo-ii-requirements-elicitation--analysis)
  - [2.1. Competidores](#21-competidores)
    - [2.1.1. Análisis competitivo](#211-análisis-competitivo)
    - [2.1.2. Estrategias y tácticas frente a competidores](#212-estrategias-y-tácticas-frente-a-competidores)
  - [2.2. Entrevistas](#22-entrevistas)
    - [2.2.1. Diseño de entrevistas](#221-diseño-de-entrevistas)
    - [2.2.2. Registro de entrevistas](#222-registro-de-entrevistas)
    - [2.2.3. Análisis de entrevistas](#223-análisis-de-entrevistas)
  - [2.3. Needfinding](#23-needfinding)
    - [2.3.1. User Personas](#231-user-personas)
    - [2.3.2. User Task Matrix](#232-user-task-matrix)
    - [2.3.3. Empathy Mapping](#233-empathy-mapping)
    - [2.3.4. As-is Scenario Mapping](#234-as-is-scenario-mapping)
  - [2.4. Ubiquitous Language](#24-ubiquitous-language)

- [Capítulo III: Requirements Specification](#capítulo-iii-requirements-specification)
  - [3.1. To-Be Scenario Mapping](#31-to-be-scenario-mapping)
  - [3.2. User Stories](#32-user-stories)
  - [3.3. Impact Mapping](#33-impact-mapping)
  - [3.4. Product Backlog](#34-product-backlog)

- [Capítulo IV: Strategic-Level Software Design](#capítulo-iv-strategic-level-software-design)
  - [4.1. Strategic-Level Attribute-Driven Design](#41-strategic-level-attribute-driven-design)
    - [4.1.1. Design Purpose](#411-design-purpose)
    - [4.1.2. Attribute-Driven Design Inputs](#412-attribute-driven-design-inputs)
      - [4.1.2.1. Primary Functionality (Primary User Stories)](#4121-primary-functionality-primary-user-stories)
      - [4.1.2.2. Quality attribute Scenarios](#4122-quality-attribute-scenarios)
      - [4.1.2.3. Constraints](#4123-constraints)
    - [4.1.3. Architectural Drivers Backlog](#413-architectural-drivers-backlog)
    - [4.1.4. Architectural Design Decisions](#414-architectural-design-decisions)
    - [4.1.5. Quality Attribute Scenario Refinements](#415-quality-attribute-scenario-refinements)
  - [4.2. Strategic-Level Domain-Driven Design](#42-strategic-level-domain-driven-design)
    - [4.2.1. EventStorming](#421-eventstorming)
    - [4.2.2. Candidate Context Discovery](#422-candidate-context-discovery)
    - [4.2.3. Domain Message Flows Modeling](#423-domain-message-flows-modeling)
    - [4.2.4. Bounded Context Canvases](#424-bounded-context-canvases)
    - [4.2.5. Context Mapping](#425-context-mapping)
  - [4.3. Software Architecture](#43-software-architecture)
    - [4.3.1. Software Architecture System Landscape Diagram](#431-software-architecture-system-landscape-diagram)
    - [4.3.2. Software Architecture Context Level Diagrams](#432-software-architecture-context-level-diagrams)
    - [4.3.3. Software Architecture Container Level Diagrams](#433-software-architecture-container-level-diagrams)
    - [4.3.4. Software Architecture Deployment Diagrams](#434-software-architecture-deployment-diagrams)

- [Capítulo V: Tactical-Level Software Design](#capítulo-v-tactical-level-software-design)
  - [5.X. Bounded Context:](#5x-bounded-context)
    - [5.X.1. Domain Layer](#5x1-domain-layer)
    - [5.X.2. Interface Layer](#5x2-interface-layer)
    - [5.X.3. Application Layer](#5x3-application-layer)
    - [5.X.4. Infrastructure Layer](#5x4-infrastructure-layer)
    - [5.X.6. Bounded Context Software Architecture Component Level Diagrams](#5x6-bounded-context-software-architecture-component-level-diagrams)
    - [5.X.7. Bounded Context Software Architecture Code Level Diagrams](#5x7-bounded-context-software-architecture-code-level-diagrams)
      - [5.X.7.1. Bounded Context Domain Layer Class Diagrams](#5x71-bounded-context-domain-layer-class-diagrams)
      - [5.X.7.2. Bounded Context Database Design Diagram](#5x72-bounded-context-database-design-diagram)

- [Capítulo VI: Solution UX Design](#capítulo-vi-solution-ux-design)
  - [6.1. Style Guidelines](#61-style-guidelines)
    - [6.1.1. General Style Guidelines](#611-general-style-guidelines)
    - [6.1.2. Web, Mobile & Devices Style Guidelines](#612-web-mobile--devices-style-guidelines)
  - [6.2. Information Architecture](#62-information-architecture)
    - [6.2.2. Labeling Systems](#622-labeling-systems)
    - [6.2.3. Searching Systems](#623-searching-systems)
    - [6.2.4. SEO Tags and Meta Tags](#624-seo-tags-and-meta-tags)
    - [6.2.5. Navigation Systems](#625-navigation-systems)
  - [6.3. Landing Page UI Design](#63-landing-page-ui-design)
    - [6.3.1. Landing Page Wireframe](#631-landing-page-wireframe)
    - [6.3.2. Landing Page Mock-up](#632-landing-page-mock-up)
  - [6.4. Applications UX/UI Design](#64-applications-uxui-design)
    - [6.4.1. Applications Wireframes](#641-applications-wireframes)
    - [6.4.2. Applications Wireflow Diagrams](#642-applications-wireflow-diagrams)
    - [6.4.3. Applications Mock-ups](#643-applications-mock-ups)
    - [6.4.4. Applications User Flow Diagrams](#644-applications-user-flow-diagrams)
  - [6.5. Applications Prototyping](#65-applications-prototyping)

- [Capítulo VII: Product Implementation, Validation & Deployment](#capítulo-vii-product-implementation-validation--deployment)
  - [7.1. Software Configuration Management](#71-software-configuration-management)
    - [7.1.1. Software Development Environment Configuration](#711-software-development-environment-configuration)
    - [7.1.2. Source Code Management](#712-source-code-management)
    - [7.1.3. Source Code Style Guide & Conventions](#713-source-code-style-guide--conventions)
    - [7.1.4. Software Deployment Configuration](#714-software-deployment-configuration)
  - [7.2. Solution Implementation](#72-solution-implementation)
    - [7.2.X. Sprint n](#72x-sprint-n)
      - [7.2.X.1. Sprint Planning n](#72x1-sprint-planning-n)
      - [7.2.X.2. Sprint Backlog n](#72x2-sprint-backlog-n)
      - [7.2.X.3. Development Evidence for Sprint Review](#72x3-development-evidence-for-sprint-review)
      - [7.2.X.4. Testing Suite Evidence for Sprint Review](#72x4-testing-suite-evidence-for-sprint-review)
      - [7.2.X.5. Execution Evidence for Sprint Review](#72x5-execution-evidence-for-sprint-review)
      - [7.2.X.6. Services Documentation Evidence for Sprint Review](#72x6-services-documentation-evidence-for-sprint-review)
      - [7.2.X.7. Software Deployment Evidence for Sprint Review](#72x7-software-deployment-evidence-for-sprint-review)
      - [7.2.X.8. Team Collaboration Insights during Sprint](#72x8-team-collaboration-insights-during-sprint)
  - [7.3. Validation Interviews](#73-validation-interviews)
    - [7.3.1. Diseño de Entrevistas](#731-diseño-de-entrevistas)
    - [7.3.2. Registro de Entrevistas](#732-registro-de-entrevistas)
    - [7.3.3. Evaluaciones según heurísticas](#733-evaluaciones-según-heurísticas)
  - [7.4. Video About-the-Product](#74-video-about-the-product)

- [Conclusiones y recomendaciones](#conclusiones-y-recomendaciones)
- [Bibliografía](#bibliografía)
- [Anexos](#anexos)

---

# Capítulo I: Introducción

## 1.1. Startup Profile

### 1.1.1. Descripción de la Startup


### 1.1.2. Perfiles de integrantes del equipo


## 1.2. Solution Profile

### 1.2.1. Antecedentes y problemática


### 1.2.2. Lean UX Process

#### 1.2.2.1. Lean UX Problem Statements


#### 1.2.2.2. Lean UX Assumptions


#### 1.2.2.3. Lean UX Hypothesis Statements


#### 1.2.2.4. Lean UX Canvas


## 1.3. Segmentos objetivo


---

# Capítulo II: Requirements Elicitation & Analysis

## 2.1. Competidores

### 2.1.1. Análisis competitivo


### 2.1.2. Estrategias y tácticas frente a competidores


## 2.2. Entrevistas

### 2.2.1. Diseño de entrevistas


### 2.2.2. Registro de entrevistas


### 2.2.3. Análisis de entrevistas


## 2.3. Needfinding

### 2.3.1. User Personas


### 2.3.2. User Task Matrix


### 2.3.3. Empathy Mapping


### 2.3.4. As-is Scenario Mapping


## 2.4. Ubiquitous Language


---

# Capítulo III: Requirements Specification

## 3.1. To-Be Scenario Mapping


## 3.2. User Stories


## 3.3. Impact Mapping


## 3.4. Product Backlog


---

# Capítulo IV: Strategic-Level Software Design

## 4.1. Strategic-Level Attribute-Driven Design

### 4.1.1. Design Purpose

El propósito del proceso de diseño de la solución **Alquila Facil** es diseñar una arquitectura de software que resuelva la problemática de dispersión de la oferta y demanda de alquileres en múltiples canales desconectados, así como la complejidad de los procesos de búsqueda y gestión identificada previamente.

- **Arrendadores**: Requieren una plataforma que maximice la visibilidad de sus propiedades y simplifique la gestión de arrendatarios potenciales.
- **Arrendatarios**: Necesitan un punto centralizado para búsqueda eficiente de propiedades y comunicación directa con arrendadores.

El diseño busca generar valor para el negocio mediante la creación de un ecosistema digital que conecte eficientemente a ambos segmentos, reduciendo fricciones en el proceso de alquiler y posibilitando la monetización a través de transacciones exitosas facilitadas por la plataforma.

### 4.1.2.2. Quality attribute Scenarios

En esta sección se incluye la especificación de la primera versión de los escenarios de atributos de calidad que tienen mayor impacto en la arquitectura de la solución, los cuales sirven de input para el proceso de diseño. La sección inicia con un texto de introducción en el cual se resume los escenarios de atributos de calidad identificados en primera instancia y se incluye el siguiente cuadro para especificar los Quality Attribute Scenarios.

Los escenarios de atributos de calidad identificados para **Alquila Fácil** se centran en garantizar una experiencia de usuario óptima, seguridad de datos, disponibilidad del sistema y escalabilidad para soportar el crecimiento esperado de la plataforma.

| Atributo | Fuente | Estímulo | Artefacto | Entorno | Respuesta | Medida |
|----------|--------|----------|-----------|---------|-----------|---------|
| **Performance** | Usuario (arrendador/arrendatario) | Búsqueda de propiedades con filtros múltiples | Sistema de búsqueda | Operación normal con 1000 usuarios concurrentes | El sistema retorna resultados de búsqueda | Tiempo de respuesta ≤ 2 segundos |
| **Availability** | Usuario | Acceso a la plataforma | Sistema completo | Operación normal | El sistema permanece disponible y operativo | Disponibilidad ≥ 99.5% del tiempo |
| **Security** | Usuario malicioso | Intento de acceso no autorizado a datos personales | Módulo de autenticación | Operación normal | El sistema bloquea el acceso y registra el intento | 100% de intentos no autorizados bloqueados |
| **Scalability** | Carga del sistema | Incremento súbito de 500 usuarios simultáneos | Sistema completo | Pico de demanda | El sistema mantiene el rendimiento sin degradación | Tiempo de respuesta se mantiene ≤ 3 segundos |
| **Usability** | Arrendatario nuevo | Registro y primera búsqueda en la plataforma | Interfaz de usuario | Operación normal | El usuario completa el proceso sin asistencia | ≥ 90% de usuarios completan el proceso en ≤ 5 minutos |
| **Modifiability** | Desarrollador | Agregación de nueva funcionalidad de pagos | Módulo de transacciones | Desarrollo | Se integra la nueva funcionalidad sin afectar módulos existentes | Implementación ≤ 2 sprints de desarrollo |


#### 4.1.2.1. Primary Functionality (Primary User Stories)


#### 4.1.2.2. Quality attribute Scenarios


#### 4.1.2.3. Constraints

En esta sección se incluye la especificación de restricciones, es decir características que no pueden ser negociadas y son impuestas por el cliente o el propio negocio como guía para la elaboración de la solución. La sección inicia con una introducción donde se resume los principales constraints a considerar. Luego de ello se incluye el cuadro de Constraints representados como Technical Stories, donde cada constraint considerado ocupa una fila.

Los constraints identificados para **Alquila Fácil** incluyen restricciones técnicas relacionadas con la seguridad de datos personales, compliance regulatorio, limitaciones presupuestarias y requerimientos de compatibilidad que son fundamentales para el éxito del proyecto.

| Technical Story ID | Título | Descripción | Criterios de Aceptación | Relacionado con (Epic ID) |
|-------------------|--------|-------------|------------------------|-------------------------|
| C-001 | Cumplimiento de Ley de Protección de Datos | El sistema debe cumplir con la normativa peruana de protección de datos personales | - Implementar consentimiento explícito para recolección de datos<br>- Permitir eliminación de datos bajo solicitud<br>- Cifrar datos personales sensibles | Epic N |
| C-002 | Compatibilidad con Navegadores Web | La aplicación web debe ser compatible con navegadores principales | - Funcionar correctamente en Chrome, Firefox, Safari y Edge<br>- Versiones de los últimos 2 años<br>- Responsive design para dispositivos móviles | Epic N |
| C-003 | Presupuesto de Infraestructura Cloud | Los costos de infraestructura no deben exceder el presupuesto inicial | - Utilizar servicios cloud con modelo de pricing escalable<br>- Implementar auto-scaling para optimizar costos<br>- Monitorear gastos mensuales | Epic N |
| C-004 | Tiempo de Desarrollo Limitado | El MVP debe estar listo en 6 meses | - Priorizar funcionalidades core<br>- Utilizar frameworks y librerías existentes<br>- Implementar metodología ágil | Epic N |
| C-005 | Integración con Servicios de Mapas | Debe integrarse con servicios de geolocalización existentes | - Utilizar API de Google Maps o similar<br>- Mostrar ubicación de propiedades en mapa<br>- Permitir búsqueda por ubicación | Epic N |
| C-006 | Seguridad en Transacciones | Las transacciones financieras deben ser seguras y auditables | - Implementar protocolo HTTPS<br>- Integrar con pasarelas de pago certificadas<br>- Mantener logs de todas las transacciones | Epic N |

### 4.1.3. Architectural Drivers Backlog

La arquitectura de la solución AlquilaFácil está guiada por un conjunto de drivers que garantizan el cumplimiento de los objetivos funcionales del sistema, los atributos de calidad priorizados y las restricciones tecnológicas definidas. Estos drivers representan las decisiones críticas que orientan el diseño de los distintos componentes, desde la autenticación segura y la gestión de espacios, hasta la integración de sensores IoT y la escalabilidad en la nube, asegurando que la plataforma sea confiable, segura y consistente para todos los usuarios.


| Driver ID | Título de Driver | Descripción | Importancia para Stakeholders | Impacto en Architecture Technical Complexity |
|-----------|-----------------|-------------|-------------------------------|---------------------------------------------|
| FD-01 | Gestión de Usuarios y Autenticación Segura | Los usuarios deben registrarse e iniciar sesión de forma segura (JWT, hashing). Base para todas las demás interacciones. | High | High |
| FD-02 | Gestión de Espacios (Locals) | Permitir a arrendadores publicar y gestionar espacios, y a arrendatarios reservarlos. | High | Medium |
| FD-03 | Integración de Sensores IoT | Captura de datos de humo, sonido, aforo y movimiento en tiempo real mediante Edge Node y Embedded App. | High | High |
| FD-04 | Notificaciones en Tiempo Real | Enviar alertas (seguridad, reservas, estado de locales) a usuarios vía Web y Mobile. | High | High |
| QAD-01 | Seguridad de Datos | Proteger datos sensibles de usuarios y locales mediante cifrado, autenticación robusta y control de acceso por roles. | High | High |
| QAD-02 | Escalabilidad en la Nube | El sistema debe soportar un incremento de usuarios, locales y sensores sin degradar el rendimiento, aprovechando Azure Cloud. | High | High |
| QAD-03 | Disponibilidad y Resiliencia | El sistema debe garantizar alta disponibilidad y recuperación rápida ante fallos (despliegue distribuido, redundancia). | High | High |
| QAD-04 | Experiencia de Usuario Consistente | El diseño UX/UI debe ser consistente entre Landing, Web App y Mobile App, con flujos simples e inclusivos. | High | Medium |
| QAD-05 | Interoperabilidad con Servicios Externos | El sistema debe integrarse con APIs externas (ej. pasarela de pagos, mapas de localización). | Medium | High |
| C-01 | Restricción de Uso de Tecnologías | Todas las capas deben implementar soluciones basadas en tecnologías establecidas (.NET, Vue y Flutter). | High | Medium |
| C-02 | Restricción de Despliegue en Azure | Todos los componentes (Backend, Edge Node, Web) deben ser desplegados en Azure según lineamientos del curso. | High | Medium |
| C-03 | Restricción de Evidencias de Desarrollo | Deben generarse evidencias (commits, ramas GitFlow, videos, despliegues) en cada sprint para evaluación académica. | High | Low |

### 4.1.4. Architectural Design Decisions

### Introducción  
Durante el **Quality Attribute Workshop** se evaluaron los drivers arquitectónicos definidos previamente, identificando patrones candidatos y analizando ventajas y desventajas para cada caso. El objetivo fue asegurar que las decisiones arquitectónicas estuvieran alineadas con los objetivos de negocio, los atributos de calidad priorizados y las restricciones del proyecto, garantizando al mismo tiempo la viabilidad técnica de la solución **AlquilaFácil**.  

El análisis se organizó en torno a los principales *drivers*, considerando tres patrones candidatos por cada uno, evaluando sus beneficios y limitaciones, y seleccionando la alternativa más adecuada para el contexto del proyecto. El resultado se presenta en la siguiente **Candidate Pattern Evaluation Matrix**, seguida de una síntesis de las decisiones finales adoptadas.

---

### Candidate Pattern Evaluation Matrix

#### D1 — Gestión de Usuarios y Autenticación (FD-01)

| Driver ID | Título de Driver | Pattern 1: JWT Stateless (Spring Security) | Pattern 2: OAuth2/OIDC con IdP | Pattern 3: Session-Based Auth |
|-----------|------------------|-------------------------------------------|--------------------------------|-------------------------------|
| FD-01 | Autenticación segura | **Pro:** Simplicidad, escalabilidad horizontal, soporte Web/Mobile. **Con:** Gestión de refresh tokens es propia. | **Pro:** Estándar enterprise, SSO, scopes. **Con:** Alta complejidad y sobrecarga para un MVP. | **Pro:** Fácil de implementar. **Con:** No escala bien, requiere sticky sessions. |

**Decisión:** Se adopta **JWT stateless** con refresh tokens y hashing de contraseñas con BCrypt/Argon2, asegurando simplicidad y escalabilidad para el MVP.

---

#### D2 — Gestión de Espacios y Reservas (FD-02)

| Driver ID | Título de Driver | Pattern 1: Monolito modular DDD | Pattern 2: Microservicios | Pattern 3: Microkernel |
|-----------|------------------|---------------------------------|---------------------------|-------------------------|
| FD-02 | Locals & Bookings | **Pro:** Organización clara, bajo costo operativo, fácil evolución. **Con:** Requiere disciplina modular. | **Pro:** Aislamiento fuerte. **Con:** Sobrecoste en despliegue y monitoreo. | **Pro:** Extensibilidad. **Con:** Complejidad innecesaria para MVP. |

**Decisión:** Se mantiene un **monolito modular con bounded contexts** (IAM, Locals, Sensors, Notifications), listo para futura evolución hacia microservicios.

---

#### D3 — Integración IoT en Tiempo Real (FD-03)

| Driver ID | Título de Driver | Pattern 1: MQTT + Edge Processing | Pattern 2: HTTP Polling | Pattern 3: AMQP directo |
|-----------|------------------|----------------------------------|-------------------------|-------------------------|
| FD-03 | Sensores IoT | **Pro:** Eficiente, bajo consumo, QoS configurable. **Con:** Requiere broker. | **Pro:** Simplicidad. **Con:** Ineficiente, mayor latencia. | **Pro:** Fiable en enterprise. **Con:** Pesado para microcontroladores. |

**Decisión:** Se adopta **MQTT con Edge Processing**, asegurando eficiencia y filtrado de datos en tiempo real.

---

#### D4 — Notificaciones en Tiempo Real (FD-04)

| Driver ID | Título de Driver | Pattern 1: WebSocket | Pattern 2: SSE + FCM | Pattern 3: Polling |
|-----------|------------------|----------------------|----------------------|--------------------|
| FD-04 | Notificaciones | **Pro:** Bidireccional y baja latencia. **Con:** Mayor complejidad de conexión. | **Pro:** Simplicidad (SSE) + fiabilidad en Mobile (FCM). **Con:** SSE es unidireccional. | **Pro:** Fácil. **Con:** Ineficiente, mala UX. |

**Decisión:** Se implementa **SSE en Web** y **FCM en Mobile**, respaldados por un bus interno Pub/Sub para distribución de eventos.

---

#### D5 — Seguridad Transversal (QAD-01)

| Driver ID | Título de Driver | Pattern 1: API Gateway | Pattern 2: Zero-Trust con JWT | Pattern 3: Vault + TLS |
|-----------|------------------|------------------------|-------------------------------|------------------------|
| QAD-01 | Seguridad | **Pro:** Rate-limiting y control centralizado. **Con:** Capa extra a mantener. | **Pro:** Control granular de accesos. **Con:** Requiere gestión de claves. | **Pro:** Cifrado integral. **Con:** Administración de Vault. |

**Decisión:** Se adopta un **API Gateway** con limitación de peticiones, junto con **JWT con roles** y **TLS end-to-end**.

---

#### D6 — Escalabilidad (QAD-02)

| Driver ID | Título de Driver | Pattern 1: CQRS light | Pattern 2: Cache distribuido | Pattern 3: Sharding |
|-----------|------------------|-----------------------|------------------------------|---------------------|
| QAD-02 | Escalabilidad | **Pro:** Consultas optimizadas, separa lecturas/escrituras. **Con:** Mayor complejidad en sincronización. | **Pro:** Mejora de rendimiento. **Con:** Riesgo en invalidación. | **Pro:** Escala masiva. **Con:** Sobrecoste para MVP. |

**Decisión:** Se combina **CQRS light** con **Redis cache**, permitiendo escalabilidad horizontal en Azure.

---

#### D7 — Disponibilidad y Resiliencia (QAD-03)

| Driver ID | Título de Driver | Pattern 1: Resilience4j | Pattern 2: Health-checks | Pattern 3: Outbox Pattern |
|-----------|------------------|------------------------|--------------------------|---------------------------|
| QAD-03 | Alta disponibilidad | **Pro:** Evita cascadas de fallos. **Con:** Configuración detallada. | **Pro:** Recuperación automática. **Con:** Limitado frente a fallos lógicos. | **Pro:** Garantiza entrega de eventos. **Con:** Complejidad extra. |

**Decisión:** Se adopta **Resilience4j**, junto con **health-checks en Azure** y **Outbox Pattern** para asegurar consistencia eventual.

---

#### D8 — Experiencia de Usuario Consistente (QAD-04)

| Driver ID | Título de Driver | Pattern 1: Design System | Pattern 2: BFF (Backend for Frontends) | Pattern 3: GraphQL |
|-----------|------------------|--------------------------|---------------------------------------|--------------------|
| QAD-04 | Consistencia UX | **Pro:** Uniformidad visual y coherencia. **Con:** Requiere mantenimiento. | **Pro:** APIs adaptadas a cada cliente. **Con:** Nuevos servicios por canal. | **Pro:** Flexibilidad de consultas. **Con:** Complejidad añadida. |

**Decisión:** Se implementa un **Design System común** y un **BFF por canal (Web/Mobile)** para asegurar consistencia.

---

#### D9 — Interoperabilidad con Servicios Externos (QAD-05)

| Driver ID | Título de Driver | Pattern 1: ACL/Adapter | Pattern 2: Integración directa | Pattern 3: ESB |
|-----------|------------------|------------------------|--------------------------------|----------------|
| QAD-05 | Integraciones | **Pro:** Aísla dependencias externas. **Con:** Sobrecoste de implementación. | **Pro:** Simplicidad. **Con:** Alto acoplamiento. | **Pro:** Orquestación potente. **Con:** Excesivo para MVP. |

**Decisión:** Se utiliza **ACL/Adapter** para cada integración externa (pagos, mapas), minimizando riesgos de acoplamiento.

---

### Síntesis de Decisiones

- **Backend:** Monolito modular con DDD, CQRS light y Redis.  
- **IoT:** MQTT con Edge Processing para sensores.  
- **Tiempo real:** SSE en Web + FCM en Mobile, con Pub/Sub interno.  
- **Seguridad:** API Gateway, JWT con roles, TLS end-to-end y secretos externos.  
- **UX:** Design System común y BFF por canal.  
- **Resiliencia:** Resilience4j + health-checks + Outbox Pattern.  
- **Integraciones:** ACL/Adapters para proveedores externos.  
- **Despliegue:** Contenerización y escalado horizontal en Azure.  

Estas decisiones permiten balancear las necesidades de negocio con la factibilidad técnica, asegurando que la solución sea **segura, escalable, resiliente y fácil de evolucionar** en el futuro.

### 4.1.5. Quality Attribute Scenario Refinements

<h2>Scenario Refinement 1 - Performance</h2>

<table>
    <tr>
        <th colspan="3" class="scenario-header">Scenario Refinement for Performance</th>
    </tr>
    <tr>
        <td><strong>Scenario(s):</strong></td>
        <td colspan="2">Búsqueda eficiente de propiedades con filtros múltiples bajo carga concurrente</td>
    </tr>
    <tr>
        <td><strong>Business Goals:</strong></td>
        <td colspan="2">Garantizar una experiencia de usuario fluida que mantenga a los usuarios comprometidos con la plataforma y reduzca la tasa de abandono durante las búsquedas</td>
    </tr>
    <tr>
        <td><strong>Relevant Quality Attributes:</strong></td>
        <td colspan="2">Performance, Usability</td>
    </tr>
    <tr>
        <td rowspan="6" class="section-title"><strong>Scenario Components</strong></td>
        <td><strong>Stimulus:</strong></td>
        <td>Arrendatario/arrendador ejecuta búsqueda con múltiples filtros (ubicación, precio, tipo de propiedad, características)</td>
    </tr>
    <tr>
        <td><strong>Stimulus Source:</strong></td>
        <td>Usuario final (arrendador/arrendatario)</td>
    </tr>
    <tr>
        <td><strong>Environment:</strong></td>
        <td>Sistema en operación normal con hasta 1000 usuarios concurrentes</td>
    </tr>
    <tr>
        <td><strong>Artifact (if known):</strong></td>
        <td>Sistema de búsqueda, base de datos, índices de búsqueda, cache distribuido</td>
    </tr>
    <tr>
        <td><strong>Response:</strong></td>
        <td>El sistema procesa la consulta, aplica filtros, consulta índices optimizados y retorna resultados paginados</td>
    </tr>
    <tr>
        <td><strong>Response Measure:</strong></td>
        <td>Tiempo de respuesta ≤ 2 segundos para el 95% de las consultas</td>
    </tr>
    <tr>
        <td><strong>Questions:</strong></td>
        <td colspan="2">¿Cómo se comporta el sistema cuando los filtros requieren joins complejos? ¿El cache distribuido maneja correctamente la invalidación de resultados?</td>
    </tr>
    <tr>
        <td><strong>Issues:</strong></td>
        <td colspan="2">Posible degradación con consultas geoespaciales complejas, necesidad de estrategias de cache inteligentes</td>
    </tr>
</table>

<hr>

<h2>Scenario Refinement 2 - Availability</h2>

<table>
    <tr>
        <th colspan="3" class="scenario-header">Scenario Refinement for Availability</th>
    </tr>
    <tr>
        <td><strong>Scenario(s):</strong></td>
        <td colspan="2">Acceso ininterrumpido a la plataforma durante picos de demanda y fallos parciales</td>
    </tr>
    <tr>
        <td><strong>Business Goals:</strong></td>
        <td colspan="2">Mantener la confianza del usuario y evitar pérdida de ingresos por indisponibilidad del servicio</td>
    </tr>
    <tr>
        <td><strong>Relevant Quality Attributes:</strong></td>
        <td colspan="2">Availability, Reliability, Recoverability</td>
    </tr>
    <tr>
        <td rowspan="6" class="section-title"><strong>Scenario Components</strong></td>
        <td><strong>Stimulus:</strong></td>
        <td>Fallo de componente crítico o pico inesperado de tráfico</td>
    </tr>
    <tr>
        <td><strong>Stimulus Source:</strong></td>
        <td>Fallo de infraestructura, sobrecarga del sistema, mantenimiento programado</td>
    </tr>
    <tr>
        <td><strong>Environment:</strong></td>
        <td>Operación normal y condiciones de estrés</td>
    </tr>
    <tr>
        <td><strong>Artifact (if known):</strong></td>
        <td>Sistema completo, load balancers, instancias redundantes, base de datos</td>
    </tr>
    <tr>
        <td><strong>Response:</strong></td>
        <td>El sistema redirige tráfico a instancias saludables, activa réplicas y mantiene operatividad</td>
    </tr>
    <tr>
        <td><strong>Response Measure:</strong></td>
        <td>Disponibilidad ≥ 99.5% mensual, tiempo de recuperación ≤ 5 minutos</td>
    </tr>
    <tr>
        <td><strong>Questions:</strong></td>
        <td colspan="2">¿Cómo se maneja la sincronización de datos entre réplicas? ¿El sistema detecta automáticamente fallos parciales?</td>
    </tr>
    <tr>
        <td><strong>Issues:</strong></td>
        <td colspan="2">Complejidad en la gestión de estado distribuido, costos de infraestructura redundante</td>
    </tr>
</table>

<hr>

<h2>Scenario Refinement 3 - Security</h2>

<table>
    <tr>
        <th colspan="3" class="scenario-header">Scenario Refinement for Security</th>
    </tr>
    <tr>
        <td><strong>Scenario(s):</strong></td>
        <td colspan="2">Protección contra accesos no autorizados y ataques maliciosos a datos sensibles</td>
    </tr>
    <tr>
        <td><strong>Business Goals:</strong></td>
        <td colspan="2">Cumplir con regulaciones de protección de datos y mantener la confianza del usuario en la seguridad de sus datos personales</td>
    </tr>
    <tr>
        <td><strong>Relevant Quality Attributes:</strong></td>
        <td colspan="2">Security, Privacy, Integrity</td>
    </tr>
    <tr>
        <td rowspan="6" class="section-title"><strong>Scenario Components</strong></td>
        <td><strong>Stimulus:</strong></td>
        <td>Intento de acceso no autorizado, ataque de fuerza bruta, inyección SQL</td>
    </tr>
    <tr>
        <td><strong>Stimulus Source:</strong></td>
        <td>Usuario malicioso, bot automatizado, atacante interno</td>
    </tr>
    <tr>
        <td><strong>Environment:</strong></td>
        <td>Operación normal, bajo ataque activo</td>
    </tr>
    <tr>
        <td><strong>Artifact (if known):</strong></td>
        <td>Módulo de autenticación, API Gateway, base de datos, logs de seguridad</td>
    </tr>
    <tr>
        <td><strong>Response:</strong></td>
        <td>Sistema bloquea acceso, registra intento, activa medidas defensivas (rate limiting, CAPTCHA)</td>
    </tr>
    <tr>
        <td><strong>Response Measure:</strong></td>
        <td>100% de intentos no autorizados bloqueados, tiempo de detección ≤ 30 segundos</td>
    </tr>
    <tr>
        <td><strong>Questions:</strong></td>
        <td colspan="2">¿El sistema diferencia entre ataques automatizados y errores legítimos de usuario? ¿Cómo se balancea seguridad con usabilidad?</td>
    </tr>
    <tr>
        <td><strong>Issues:</strong></td>
        <td colspan="2">Falsos positivos que bloqueen usuarios legítimos, complejidad en la gestión de tokens JWT</td>
    </tr>
</table>

<hr>

<h2>Scenario Refinement 4 - Scalability</h2>

<table>
    <tr>
        <th colspan="3" class="scenario-header">Scenario Refinement for Scalability</th>
    </tr>
    <tr>
        <td><strong>Scenario(s):</strong></td>
        <td colspan="2">Crecimiento súbito de usuarios simultáneos sin degradación del rendimiento</td>
    </tr>
    <tr>
        <td><strong>Business Goals:</strong></td>
        <td colspan="2">Soportar el crecimiento del negocio sin requerir rediseño arquitectónico mayor, optimizando costos de infraestructura</td>
    </tr>
    <tr>
        <td><strong>Relevant Quality Attributes:</strong></td>
        <td colspan="2">Scalability, Performance, Cost-effectiveness</td>
    </tr>
    <tr>
        <td rowspan="6" class="section-title"><strong>Scenario Components</strong></td>
        <td><strong>Stimulus:</strong></td>
        <td>Incremento de 500 usuarios simultáneos adicionales en corto período</td>
    </tr>
    <tr>
        <td><strong>Stimulus Source:</strong></td>
        <td>Crecimiento orgánico, campaña de marketing, evento viral</td>
    </tr>
    <tr>
        <td><strong>Environment:</strong></td>
        <td>Pico de demanda, operación bajo estrés</td>
    </tr>
    <tr>
        <td><strong>Artifact (if known):</strong></td>
        <td>Sistema completo, auto-scaling groups, load balancers, base de datos</td>
    </tr>
    <tr>
        <td><strong>Response:</strong></td>
        <td>Sistema activa auto-scaling, distribuye carga, mantiene rendimiento estable</td>
    </tr>
    <tr>
        <td><strong>Response Measure:</strong></td>
        <td>Tiempo de respuesta se mantiene ≤ 3 segundos, escalado automático en ≤ 2 minutos</td>
    </tr>
    <tr>
        <td><strong>Questions:</strong></td>
        <td colspan="2">¿El auto-scaling considera métricas de negocio además de técnicas? ¿Cómo se manejan las sesiones durante el escalado?</td>
    </tr>
    <tr>
        <td><strong>Issues:</strong></td>
        <td colspan="2">Latencia en el aprovisionamiento de recursos, costos variables impredecibles</td>
    </tr>
</table>

<hr>

<h2>Scenario Refinement 5 - Usability</h2>

<table>
    <tr>
        <th colspan="3" class="scenario-header">Scenario Refinement for Usability</th>
    </tr>
    <tr>
        <td><strong>Scenario(s):</strong></td>
        <td colspan="2">Onboarding intuitivo para nuevos usuarios sin experiencia previa en la plataforma</td>
    </tr>
    <tr>
        <td><strong>Business Goals:</strong></td>
        <td colspan="2">Maximizar conversión de visitantes a usuarios registrados y reducir abandono durante el proceso de registro inicial</td>
    </tr>
    <tr>
        <td><strong>Relevant Quality Attributes:</strong></td>
        <td colspan="2">Usability, Accessibility, Learnability</td>
    </tr>
    <tr>
        <td rowspan="6" class="section-title"><strong>Scenario Components</strong></td>
        <td><strong>Stimulus:</strong></td>
        <td>Nuevo arrendatario accede por primera vez y realiza registro completo + primera búsqueda</td>
    </tr>
    <tr>
        <td><strong>Stimulus Source:</strong></td>
        <td>Arrendatario nuevo sin experiencia previa en la plataforma</td>
    </tr>
    <tr>
        <td><strong>Environment:</strong></td>
        <td>Operación normal, interfaz web/móvil</td>
    </tr>
    <tr>
        <td><strong>Artifact (if known):</strong></td>
        <td>Interfaz de usuario, formularios de registro, sistema de onboarding, tutoriales</td>
    </tr>
    <tr>
        <td><strong>Response:</strong></td>
        <td>Sistema guía al usuario a través del proceso con indicadores claros y validación en tiempo real</td>
    </tr>
    <tr>
        <td><strong>Response Measure:</strong></td>
        <td>≥ 90% de usuarios completan registro y primera búsqueda en ≤ 5 minutos sin asistencia</td>
    </tr>
    <tr>
        <td><strong>Questions:</strong></td>
        <td colspan="2">¿El sistema adapta el onboarding según el dispositivo utilizado? ¿Se consideran usuarios con diferentes niveles de alfabetización digital?</td>
    </tr>
    <tr>
        <td><strong>Issues:</strong></td>
        <td colspan="2">Balance entre simplicidad y recolección de información necesaria, accesibilidad para usuarios con discapacidades</td>
    </tr>
</table>

## 4.2. Strategic-Level Domain-Driven Design

### 4.2.1. EventStorming
<p>
EventStorming es una técnica de modelado colaborativo e iterativo que permite analizar a fondo problemas complejos y de gran escala, ayudando a descubrir una amplia variedad de detalles y desafíos involucrados.</p>

![Event Storming](images/cap-4/strategic-level/imagen_1.png)

Enlace del Miroo para verlo completo: https://miro.com/app/board/uXjVIBJ9674=/?share_link_id=539583810560

### 4.2.2. Candidate Context Discovery
<strong>Step 1: Unstructured Exploration</strong>:<br>
<p>En la etapa inicial del EventStorming, se lleva a cabo una sesión de lluvia de ideas destinada a descubrir los eventos clave del dominio vinculados al negocio analizado. Es importante redactar estos eventos utilizando verbos en pasado, ya que deben reflejar acciones que ya han sucedido dentro del sistema o proceso.</p>

![Event Storming](images/cap-4/strategic-level/imagen_2.png)


<p>Realizamos una sesión de lluvia de ideas para identificar todos los eventos relevantes que el sistema de reservas de locales con tecnología IoT debe manejar. En esta etapa inicial del Event Storming se mapearon eventos clave como la creación de cuentas, registro y actualización de locales, postulaciones y confirmación de reservas, así como la entrada y salida del arrendatario mediante pulsera NFC. También se incluyeron eventos generados por sensores, como detección de humo, sobreaforo y accesos no autorizados, fundamentales para garantizar el cumplimiento de las normas del local. Se consideraron alertas automáticas enviadas tanto al arrendador como al arrendatario en caso de infracciones, así como acciones relacionadas con la gestión de reportes, historial de asistencia e interacciones con la app móvil. Este mapeo inicial permite tener una visión integral de todos los comportamientos que el sistema debe registrar y reaccionar para brindar una solución de monitoreo y control eficaz para ambas partes involucradas</p>


<strong>Step 2: Timelines</strong>:<br>
<p>En esta segunda etapa, se toman los eventos de dominio identificados y se ordenan cronológicamente según su secuencia natural dentro del proceso. El primer enfoque consiste en construir un "camino feliz" (happy path), es decir, una secuencia ideal en la que todas las acciones se ejecutan correctamente y el flujo del sistema se desarrolla sin inconvenientes. Una vez definido este escenario óptimo, se incorporan variaciones o situaciones alternativas que representen posibles errores, fallos o condiciones excepcionales dentro del flujo operativo.</p>


![Event Storming](images/cap-4/strategic-level/imagen_3.png)


<p>En esta segunda fase del Event Storming, organizamos los eventos de dominio identificados previamente en flujos secuenciales que reflejan cómo se comporta el sistema ante diferentes escenarios relacionados con el proceso de reserva, ingreso y monitoreo del uso del local. El flujo principal sigue un "camino feliz" donde el usuario inicia sesión, selecciona un local, crea una reserva, asiste con su pulsera NFC, y completa la experiencia sin incidentes, incluyendo la generación de reportes y la calificación del local.
Además, se contemplan trayectorias alternativas que incluyen detecciones de humo, ruido o exceso de aforo, así como ingresos fuera de horario o con pulseras no autorizadas. Estas situaciones activan mecanismos de control como el registro de infracciones, el envío de notificaciones al arrendador o arrendatario, y la actualización del historial de eventos. Esta organización permite visualizar cómo el sistema reacciona ante distintos contextos operativos, sentando las bases para diseñar una lógica robusta, trazable y automatizada tanto en la app móvil como en la plataforma web.</p>


<strong>Step 3: Paint Points</strong>:<br>
<p>Una vez que los eventos fueron organizados en una secuencia temporal, utilizamos esta visión global del proceso para detectar áreas clave que requieren atención. Estos puntos críticos pueden manifestarse como cuellos de botella operativos, tareas manuales susceptibles de automatización, ausencia de documentación relevante o vacíos en el entendimiento del dominio. Esta revisión permite anticipar mejoras y definir prioridades para el diseño del sistema.</p>


![Event Storming](images/cap-4/strategic-level/imagen_4.png)


<p>En esta fase del Event Storming, se identificaron los puntos críticos del sistema y se documentaron preguntas clave que deben ser respondidas para garantizar el correcto funcionamiento del proceso de reservas, ingreso y monitoreo de locales. Estas preguntas se integran directamente en los flujos de eventos y permiten explorar escenarios como la verificación de acceso mediante pulseras NFC, la validación del cronograma de reservas o la forma en que se detectan eventos de sobreaforo, humo o ruido durante el uso del local.
</p>




<strong>Step 4: Pivotal Points</strong>:<br>
<p>Una vez que se ha construido la línea de eventos completa, incluyendo los puntos de dolor, se procede a identificar aquellos eventos relevantes que representan un cambio significativo en el contexto o en la etapa del proceso. Estos se conocen como eventos principales, y se utilizan como puntos de corte dentro del flujo, marcando una transición clara entre lo que ocurre antes y lo que sucede después. Para visualizarlos, se incorpora una barra vertical que divide los eventos previos de los posteriores a dicho hito</p>


![Event Storming](images/cap-4/strategic-level/imagen_5.png)


<p>Hemos identificado los eventos principales (pivotal points) que marcan transiciones clave dentro del sistema de reservas y monitoreo de locales con tecnología IoT. Estos eventos delimitan fases importantes del proceso y permiten establecer momentos en los que es necesario validar decisiones fundamentales para garantizar el correcto funcionamiento del sistema.
</p>



<strong>Step 5: Commands</strong>:<br>
<p>En esta etapa también incorporamos los comandos, los cuales representan las acciones que desencadenan uno o varios eventos dentro del sistema. A diferencia de los eventos de dominio, que describen hechos ya ocurridos, los comandos se expresan en forma imperativa, indicando las operaciones que deben llevarse a cabo en el sistema para provocar un cambio en su estado o avanzar en el flujo del proceso</p>


![Event Storming](images/cap-4/strategic-level/imagen_6.png)



<strong>Step 6: Policies</strong>:<br>
<p>En esta etapa se identifican las políticas de automatización, es decir, reglas que permiten que ciertos comandos se ejecuten automáticamente en respuesta a eventos del dominio. Esto implica que, al producirse un evento específico dentro del sistema, se dispare de forma inmediata la acción correspondiente, sin intervención manual. En otras palabras, se establece una relación directa entre eventos y comandos, permitiendo que el sistema reaccione de forma autónoma ante situaciones previamente definidas.</p>


![Event Storming](images/cap-4/strategic-level/imagen_7.png)


<p>Definimos y organizamos las políticas de automatización que permiten ejecutar comandos de forma automática ante la ocurrencia de eventos clave dentro del sistema. Estas políticas cubren la recolección y envío de datos, la asignación de pulseras NFC, la validación de accesos, la generación de reportes del local, y el monitoreo de condiciones críticas como sobreaforo, humo o ruido en el recinto.
También se estructuraron reglas para el disparo automático de alertas al detectar eventos que representan infracciones, asegurando que el sistema reaccione de manera inmediata sin intervención manual.
</p>


<strong>Step 7: Read models</strong>:<br>
<p>En esta etapa, incorporamos los modelos de lectura, que representan las vistas de datos del sistema que los agentes (ya sean usuarios o componentes del sistema) utilizan para decidir si deben ejecutar un comando. Esto implica definir visualizaciones específicas como reportes de locales, paneles de monitoreo de aforo, alertas en tiempo real por infracciones, estado de las reservas, historial de asistencia y validación de acceso mediante NFC.</p>


![Event Storming](images/cap-4/strategic-level/imagen_7.png)



<strong>Step 8: External Systems</strong>:<br>
<p>En este paso, integramos al modelo los sistemas externos, es decir, aquellos que están fuera del dominio principal del sistema que estamos diseñando. Estos sistemas pueden intervenir ejecutando comandos hacia nuestro sistema (como entradas) o bien recibir información generada por eventos del dominio (como salidas).</p>


![Event Storming](images/cap-4/strategic-level/imagen_8.png)


<p>Incorporamos los sistemas externos que interactúan con el dominio principal, representados con etiquetas rojas. Se identificaron elementos clave como el lector NFC y los sensores IoT (aforo, humo, ruido), los cuales permiten recolectar datos del entorno físico y activan eventos automatizados dentro del sistema. Además, se detallaron las políticas de envío de datos, representadas en color morado, las cuales se encargan de transmitir información relevante a la nube o al backend en tiempo real.
</p>



<strong>Step 9: Aggregates</strong>:<br>
<p>Después de haber definido todos los eventos y comandos del sistema, procedemos a agrupar aquellos conceptos que guardan una relación directa dentro de unidades llamadas agregados. Estos agregados representan componentes clave del dominio, ya que son los encargados de recibir comandos y, a partir de ellos, generar los eventos correspondientes que reflejan los cambios en el estado del sistema</p>


![Event Storming](images/cap-4/strategic-level/imagen_9.png)


<p>Identificamos los agregados del dominio que encapsulan la lógica de negocio principal del sistema de reservas con IoT. Cada aggregate agrupa los comandos y eventos que afectan una misma unidad lógica, asegurando la coherencia de los datos y el cumplimiento de las reglas definidas. Se establecieron agregados como User, para el control de identidad y autenticación; Locale, encargado del ciclo de vida de los locales; Reservation, que gestiona las reservas y su estado; AccessControl, que regula el ingreso mediante pulseras NFC; y Monitoring, responsable de registrar condiciones detectadas por sensores IoT. Esta estructura permite organizar el dominio de forma modular y consistente, facilitando el mantenimiento y escalabilidad del sistema
</p>


<strong>Step 10: Bounded Context</strong>:<br>
<p>Finalmente, agrupamos los agregados que mantienen una relación directa entre sí, ya sea porque comparten funciones estrechamente relacionadas o porque están conectados a través de ciertas políticas de negocio. Estos conjuntos de agregados constituyen candidatos naturales para establecer los contextos delimitados (Bounded Contexts) del sistema, permitiendo organizar el dominio en módulos coherentes y bien definidos según sus responsabilidades y reglas específicas.</p>


![Event Storming](images/cap-4/strategic-level/imagen_10.png)



<p>En esta etapa final, estructuramos el sistema en Bounded Contexts claramente definidos, agrupando los agregados que comparten responsabilidades, reglas de negocio o interacciones comunes. Esta segmentación permite organizar el dominio en módulos independientes, cada uno con un propósito específico y una lógica coherente.
Se identificaron cinco contextos principales:
IAM (Identity and Access Management): encargado de la gestión de identidad, registro, autenticación y control de acceso de los usuarios al sistema.
Locals: responsable del registro, actualización, visualización y reporte de los locales disponibles para reserva.
Booking: gestiona todo el ciclo de vida de las reservas, incluyendo su creación, modificación, finalización y calificación posterior.
Monitoring: controla la recolección de datos desde sensores IoT (como aforo, humo o ruido), valida reglas del local y registra infracciones.
Notifications: administra el envío de alertas a usuarios o arrendadores cuando se detectan condiciones críticas o eventos relevantes.
Cada uno de estos contextos delimita claramente su modelo de datos, comandos y eventos, lo que permite mantener una arquitectura modular, trazable y preparada para escalar según las necesidades del sistema.
</p>

### 4.2.3. Domain Message Flows Modeling
<strong>Scenario 1: Local reservation</strong>:<br>
![Event Storming](images/cap-4/strategic-level/imagen_11.jpeg)

<strong>Scenario 2: Local comment creation</strong>:<br>
![Event Storming](images/cap-4/strategic-level/imagen_12.jpeg)

<strong>Scenario 3: Tenant exceeds local capacity</strong>:<br>
![Event Storming](images/cap-4/strategic-level/imagen_13.jpeg)

<strong>Scenario 4: Tenant exceeds noise level</strong>:<br>
![Event Storming](images/cap-4/strategic-level/imagen_14.jpeg)

<strong>Scenario 5: Tenant tries to enter the premises outside of reservation hours
</strong>:<br>
![Event Storming](images/cap-4/strategic-level/imagen_15.jpeg)


### 4.2.4. Bounded Context Canvases
![Event Storming](images/cap-4/strategic-level/imagen_16.jpeg)
![Event Storming](images/cap-4/strategic-level/imagen_17.jpeg)
![Event Storming](images/cap-4/strategic-level/imagen_18.jpeg)

### 4.2.5. Context Mapping
##### 1. Pasos para Crear el Context Mapping
###### 1.1. Identificación de los Bounded Contexts
- IAM (Identity and Access Management)
- Locals
- Booking
- Monitoring
- Notifications
###### 1.2. Identificación de Relaciones Iniciales
- IAM ⭤ Booking: Relación de Customer/Supplier.
- IAM proporciona la autenticación y control de acceso, mientras Booking consume la identidad para permitir la creación de reservas.
- Locals ⭤ Booking: Relación de Customer/Supplier.
- Locals administra la disponibilidad y características de los espacios, Booking consulta esa información para registrar una reserva.
- Booking ⭤ Monitoring: Relación de Customer/Supplier.
- Booking genera el inicio y fin de la reserva, mientras Monitoring supervisa el cumplimiento de normas durante ese periodo.
- Monitoring ⭤ Notifications: Relación de Conformist.
- Notifications se adapta a los eventos generados por Monitoring para emitir alertas sin modificar la estructura de los datos.
- Booking ⭤ Notifications: Relación de Conformist.
- Booking puede generar eventos que Notifications transforma en mensajes para usuarios.


##### 2. Análisis de Alternativas y Preguntas Clave
###### 2.1. ¿Qué pasaria si movemos la gestión de reportes de locales desde Locals a Monitoring?
Impacto: Monitoring tendría control total del estado operacional del local.
Se perdería la separación entre información estática del local (Locals) y condiciones temporales (Monitoring).
Discusión:
No se recomienda el cambio. Mantener reportes en Locals permite independencia de la información operativa.

###### 2.2. ¿Y si separáramos Monitoring en dos contexts: SensorEvents y RuleValidation?
Impacto:
Permitiría escalar el procesamiento de eventos por separado del motor de reglas.
Mayor complejidad y necesidad de sincronización.
Discusión:
Podría evaluarse si los volúmenes de datos lo justifican, pero por ahora es preferible mantenerlo unificado.

###### 2.3. ¿Podría Notifications compartir un kernel con Booking?
Impacto:
Se podría optimizar el modelo de eventos compartidos.
Riesgo de acoplamiento excesivo.
Discusión:
Mejor mantener el contrato como evento público. No se recomienda un shared kernel.


###### 2.4. ¿Sería viable mover la asignación de pulseras NFC de Booking a IAM?
Impacto:
IAM controlaría identidad + dispositivo asignado.
Aumenta la carga de IAM, mezcla responsabilidades de autenticación con gestión de dispositivos.
Discusión:
Se recomienda mantener la asignación en Booking para no contaminar IAM con lógica operacional.

##### 3. Alternativas Recomendadas de Context Mapping
Mantener la separación entre datos estáticos (Locals) y monitoreo operacional (Monitoring).
No dividir Monitoring aún, salvo que se presenten cuellos de botella o necesidades de escalabilidad por volumen de eventos.
Evitar compartir kernels entre contexts; priorizar integración por eventos públicos.
Mantener la asignación de dispositivos dentro de Booking.
##### 4. Patrones de Relaciones Sugeridos
- Customer/Supplier: IAM ⭤ Booking, Locals ⭤ Booking, Booking ⭤ Monitoring
- Conformist: Monitoring ⭤ Notifications, Booking ⭤ Notifications
- Published Language: Monitoring publica eventos con estructura conocida para consumo externo (ej. por Notifications)
- Anti-Corruption Layer (ACL): Podría evaluarse entre Monitoring y cualquier motor externo de validación de reglas en el futuro

![Event Storming](images/cap-4/strategic-level/imagen_19.png)


## 4.3. Software Architecture

### 4.3.1. Software Architecture System Landscape Diagram


### 4.3.2. Software Architecture Context Level Diagrams


### 4.3.3. Software Architecture Container Level Diagrams


### 4.3.4. Software Architecture Deployment Diagrams


---

# Capítulo V: Tactical-Level Software Design

## 5.X. Bounded Context:

### 5.X.1. Domain Layer


### 5.X.2. Interface Layer


### 5.X.3. Application Layer


### 5.X.4. Infrastructure Layer


### 5.X.6. Bounded Context Software Architecture Component Level Diagrams


### 5.X.7. Bounded Context Software Architecture Code Level Diagrams

#### 5.X.7.1. Bounded Context Domain Layer Class Diagrams


#### 5.X.7.2. Bounded Context Database Design Diagram


---

# Capítulo VI: Solution UX Design

## 6.1. Style Guidelines

### 6.1.1. General Style Guidelines


### 6.1.2. Web, Mobile & Devices Style Guidelines


## 6.2. Information Architecture

### 6.2.2. Labeling Systems


### 6.2.3. Searching Systems


### 6.2.4. SEO Tags and Meta Tags


### 6.2.5. Navigation Systems


## 6.3. Landing Page UI Design

### 6.3.1. Landing Page Wireframe


### 6.3.2. Landing Page Mock-up


## 6.4. Applications UX/UI Design

### 6.4.1. Applications Wireframes


### 6.4.2. Applications Wireflow Diagrams


### 6.4.3. Applications Mock-ups


### 6.4.4. Applications User Flow Diagrams


## 6.5. Applications Prototyping


---

# Capítulo VII: Product Implementation, Validation & Deployment

## 7.1. Software Configuration Management

### 7.1.1. Software Development Environment Configuration


### 7.1.2. Source Code Management


### 7.1.3. Source Code Style Guide & Conventions


### 7.1.4. Software Deployment Configuration


## 7.2. Solution Implementation

### 7.2.X. Sprint n

#### 7.2.X.1. Sprint Planning n


#### 7.2.X.2. Sprint Backlog n


#### 7.2.X.3. Development Evidence for Sprint Review


#### 7.2.X.4. Testing Suite Evidence for Sprint Review


#### 7.2.X.5. Execution Evidence for Sprint Review


#### 7.2.X.6. Services Documentation Evidence for Sprint Review


#### 7.2.X.7. Software Deployment Evidence for Sprint Review


#### 7.2.X.8. Team Collaboration Insights during Sprint


## 7.3. Validation Interviews

### 7.3.1. Diseño de Entrevistas


### 7.3.2. Registro de Entrevistas


### 7.3.3. Evaluaciones según heurísticas


## 7.4. Video About-the-Product


---

# Conclusiones y recomendaciones


---

# Bibliografía


---

# Anexos
